from datetime import timedelta
from typing import Any, Generic, Self, TypeVar

from pyreqwest.http import Url
from pyreqwest.http.cookie import CookieStore
from pyreqwest.middleware.types import BlockingMiddleware, Middleware
from pyreqwest.proxy import Proxy
from pyreqwest.request import BaseRequestBuilder, BlockingRequestBuilder, RequestBuilder
from pyreqwest.types import HeadersType

_RB = TypeVar("_RB", bound=BaseRequestBuilder)

class BaseClient(Generic[_RB]):
    def request(self, method: str, url: Url | str) -> _RB: ...
    def get(self, url: Url | str) -> _RB: ...
    def post(self, url: Url | str) -> _RB: ...
    def put(self, url: Url | str) -> _RB: ...
    def patch(self, url: Url | str) -> _RB: ...
    def delete(self, url: Url | str) -> _RB: ...
    def head(self, url: Url | str) -> _RB: ...

class Client(BaseClient[RequestBuilder]):
    async def __aenter__(self) -> Self: ...
    async def __aexit__(self, *args: object, **kwargs: Any) -> None: ...
    async def close(self) -> None: ...

class BlockingClient(BaseClient[BlockingRequestBuilder]):
    def __enter__(self) -> Self: ...
    def __exit__(self, *args: object, **kwargs: Any) -> None: ...
    def close(self) -> None: ...

class BaseClientBuilder:
    def __init__(self) -> None: ...
    def base_url(self, url: Url | str) -> Self: ...
    def runtime(self, runtime: Runtime) -> Self: ...
    def max_connections(self, max_connections: int | None) -> Self: ...
    def error_for_status(self, enable: bool) -> Self: ...
    def user_agent(self, value: str) -> Self: ...
    def default_headers(self, headers: HeadersType) -> Self: ...
    def cookie_store(self, enable: bool) -> Self: ...
    def cookie_provider(self, provider: CookieStore) -> Self: ...
    def gzip(self, enable: bool) -> Self: ...
    def brotli(self, enable: bool) -> Self: ...
    def zstd(self, enable: bool) -> Self: ...
    def deflate(self, enable: bool) -> Self: ...
    def max_redirects(self, max_redirects: int) -> Self: ...
    def referer(self, enable: bool) -> Self: ...
    def proxy(self, proxy: Proxy) -> Self: ...
    def no_proxy(self) -> Self: ...
    def timeout(self, timeout: timedelta) -> Self: ...
    def read_timeout(self, timeout: timedelta) -> Self: ...
    def connect_timeout(self, timeout: timedelta) -> Self: ...
    def pool_timeout(self, timeout: timedelta) -> Self: ...
    def pool_idle_timeout(self, timeout: timedelta) -> Self: ...
    def pool_max_idle_per_host(self, max_idle: int) -> Self: ...
    def http1_title_case_headers(self) -> Self: ...
    def http1_allow_obsolete_multiline_headers_in_responses(self, value: bool) -> Self: ...
    def http1_ignore_invalid_headers_in_responses(self, value: bool) -> Self: ...
    def http1_allow_spaces_after_header_name_in_responses(self, value: bool) -> Self: ...
    def http1_only(self) -> Self: ...
    def http09_responses(self) -> Self: ...
    def http2_prior_knowledge(self) -> Self: ...
    def http2_initial_stream_window_size(self, value: int | None) -> Self: ...
    def http2_initial_connection_window_size(self, value: int | None) -> Self: ...
    def http2_adaptive_window(self, enabled: bool) -> Self: ...
    def http2_max_frame_size(self, value: int | None) -> Self: ...
    def http2_max_header_list_size(self, value: int) -> Self: ...
    def http2_keep_alive_interval(self, value: timedelta | None) -> Self: ...
    def http2_keep_alive_timeout(self, timeout: timedelta) -> Self: ...
    def http2_keep_alive_while_idle(self, enabled: bool) -> Self: ...
    def tcp_nodelay(self, enabled: bool) -> Self: ...
    def local_address(self, addr: str | None) -> Self: ...
    def interface(self, value: str) -> Self: ...
    def tcp_keepalive(self, value: timedelta | None) -> Self: ...
    def tcp_keepalive_interval(self, value: timedelta | None) -> Self: ...
    def tcp_keepalive_retries(self, value: int | None) -> Self: ...
    def tcp_user_timeout(self, timeout: timedelta | None) -> Self: ...
    def add_root_certificate_der(self, cert: bytes) -> Self: ...
    def add_root_certificate_pem(self, cert: bytes) -> Self: ...
    def add_crl_pem(self, cert: bytes) -> Self: ...
    def tls_built_in_root_certs(self, enable: bool) -> Self: ...
    def tls_built_in_webpki_certs(self, enable: bool) -> Self: ...
    def identity_pem(self, buf: bytes) -> Self: ...
    def danger_accept_invalid_hostnames(self, enable: bool) -> Self: ...
    def danger_accept_invalid_certs(self, enable: bool) -> Self: ...
    def tls_sni(self, enable: bool) -> Self: ...
    def min_tls_version(self, value: str) -> Self: ...
    def max_tls_version(self, value: str) -> Self: ...
    def https_only(self, enable: bool) -> Self: ...
    def resolve(self, domain: str, ip: str, port: int) -> Self: ...

class ClientBuilder(BaseClientBuilder):
    def build(self) -> Client: ...
    def with_middleware(self, middleware: Middleware) -> Self: ...

class BlockingClientBuilder(BaseClientBuilder):
    def build(self) -> BlockingClient: ...
    def with_middleware(self, middleware: BlockingMiddleware) -> Self: ...

class Runtime:
    def __init__(self, *, thread_name: str | None = None) -> None: ...
    async def close(self) -> None: ...
